var searchIndex = {};
searchIndex["rust_higher_kinded_types"] = {"doc":"This is a simple library designed to showcase a prospective design for a\nfamily of zipper-like graph traversal traits. These traits may be\nimplemented over varying graph implementations (adjacency list, adjacency\nmatrix, lazily constructed infinite graph, actual zippers, etc.).","items":[[0,"nav_types","rust_higher_kinded_types","Types that can traverse the graph and cannot modify its structure. These\ntypes are backed by a read-only borrow of graph data, so multiple instances\nof them may coexist.",null,null],[8,"NavTypes","rust_higher_kinded_types::nav_types","",null,null],[16,"NavVertex","","",0,null],[16,"NavEdge","","",0,null],[16,"NavInEdgeCollection","","",0,null],[16,"NavOutEdgeCollection","","",0,null],[8,"Vertex","","",null,null],[16,"Types","","",1,null],[10,"data","","",1,null],[10,"out_edges","","",1,null],[10,"in_edges","","",1,null],[8,"Edge","","",null,null],[16,"Types","","",2,null],[10,"data","","",2,null],[10,"source","","",2,null],[10,"target","","",2,null],[8,"InEdgeCollection","","",null,null],[16,"Types","","",3,null],[16,"Iter","","",3,null],[10,"len","","",3,null],[11,"is_empty","","",3,null],[10,"target","","",3,null],[10,"iter","","",3,null],[8,"OutEdgeCollection","","",null,null],[16,"Types","","",4,null],[16,"Iter","","",4,null],[10,"len","","",4,null],[11,"is_empty","","",4,null],[10,"source","","",4,null],[10,"iter","","",4,null],[0,"mut_types","rust_higher_kinded_types","Types that can traverse the graph and may modify its structure. These types\nare backed by a mutable borrow of graph data, so multiple active\n(unborrowed) instances cannot exist.",null,null],[8,"MutTypes","rust_higher_kinded_types::mut_types","",null,null],[16,"MutVertex","","",5,null],[16,"MutEdge","","",5,null],[16,"MutInEdgeCollection","","",5,null],[16,"MutOutEdgeCollection","","",5,null],[8,"Vertex","","",null,null],[16,"Types","","",6,null],[10,"data","","",6,null],[10,"data_mut","","Since we have mutable access to the underlying graph, we can get a\nmutable borrow of its actual contents.",6,null],[10,"to_out_edges","","Consumes `self` entirely and passes the underlying borrow to a list of\noutgoing edges.",6,null],[10,"to_in_edges","","Consumes `self` entirely and passes the underlying borrow to a list of\nincomign edges.",6,null],[10,"out_edges","","Vertex and its kindred in the mut_types module are backed by a mutable\nborrow of a graph structure. This means that it is not possible to have\nmultiple live instances of impls of these traits (say, a `Vertex` and an\n`Edge`) that are backed by the same graph. For flexibility, it is\ndesirable to be able to create a read-only borrow from a\n`mut_types::Vertex`, so that we can do something like:",6,null],[8,"Edge","","",null,null],[16,"Types","","",7,null],[8,"InEdgeCollection","","",null,null],[16,"Types","","",8,null],[16,"Iter","","",8,null],[8,"OutEdgeCollection","","",null,null],[16,"Types","","",9,null],[16,"Iter","","",9,null],[8,"GraphTypes","rust_higher_kinded_types","Base types that the graph defines a structure over.",null,null],[16,"VertexData","","The type of data at vertices.",10,null],[16,"EdgeData","","The type of data at edges.",10,null],[8,"BoundedIterator","","When iterating over components of a graph structure, we need to give a name\nto the borrow of the underlying graph. This trait does so.",null,null]],"paths":[[8,"NavTypes"],[8,"Vertex"],[8,"Edge"],[8,"InEdgeCollection"],[8,"OutEdgeCollection"],[8,"MutTypes"],[8,"Vertex"],[8,"Edge"],[8,"InEdgeCollection"],[8,"OutEdgeCollection"],[8,"GraphTypes"]]};
initSearch(searchIndex);
